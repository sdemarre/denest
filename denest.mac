is_sqrt(expr):=not atom(expr) and is(op(expr)='sqrt)$
is_power(expr):=not atom(expr) and is(op(expr)="^")$
is_square(expr):=not atom(expr) and is_power(expr) and args(expr)[2]=2$
is_sum(expr):=not atom(expr) and is(op(expr)="+")$
is_single_sqrt(expr):=is_sqrt(expr) and length(args(expr))=1$
is_product(expr):=not atom(expr) and is(op(expr)="*")$
is_const_times_sqrt(expr):=is_product(expr) and length(args(expr)) = 2 and atom(args(expr)[1]) and is_sqrt(args(expr)[2])$
  
/* sqrt(x^2)->x  */
denest_if_square(expr):=
if is_single_sqrt(expr) and is_square(args(expr)[1])
then
  args(args(expr)[1])[1]
else
  expr$
/* expr = b*sqrt(r)->[b,r] 
assumes is_const_times_sqrt(expr)*/
extract_const_sqrt(expr):=[args(expr)[1],args(args(expr)[2])[1]]$
  
/* if args(expr)[i] is of the form b*sqrt(r) then return [expr-b*sqrt(r),b,r]
assumes expr is a sum */
denest_split_sqrt_expr(expr,i):=block([arg_i:args(expr)[i],b,r],
  if is_product(arg_i) and is_const_mul_sqrt(arg_i) then
    block([b,r],
      [b,r]:extract_const_sqrt(arg_i),
      [expr - arg_i,b,r]))$
				  
    
/* returns all possible sqrt(a+b*sqrt(r)) decompositions of expr */
denest_match_simple(expr):=
  block([a:[],b:[],r:[]],
    if is_sqrt(expr) and is_sum(args(expr)[1]) then
      block([i,sqrt_arg:args(expr)[1]],
	for i : 1 thru length(sum_expr) do
           block([s:denest_split_sqrt_expr(sqrt_arg,i)],
	     if not atom(s) then block([],
				   a:cons(s[1],a),
				   b:cons(s[2],b),
				   r:cons(s[3],r))))
					     
    else
      expr,
    [a,b,r])$
	    
	
denest(depth,nested_exprs):=block([m,n,N,d,s,DENESTED],
       m:length(nested_exprs),
       if depth = 1 then return(map(denest_if_square,nested_exprs))
       else
       block([a,b,r],
	     [a,b,r] = denest_match_simple_all(nested_exprs),
	     if all_list_elements_equal(r) then
	     	block([],
		N:makelist(sqrt(a[i]^2-b[i]^2*r[1]),i,1,m))
	     else
	        DENESTED:nested_exprs
       ),
       DENESTED);
