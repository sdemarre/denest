is_sqrt(expr):=not atom(expr) and is(op(expr)='sqrt)$
is_power(expr):=not atom(expr) and is(op(expr)="^")$
is_square(expr):=not atom(expr) and is_power(expr) and args(expr)[2]=2$
is_sum(expr):=not atom(expr) and is(op(expr)="+")$
is_single_sqrt(expr):=is_sqrt(expr) and length(args(expr))=1$
is_product(expr):=not atom(expr) and is(op(expr)="*")$
is_neg(expr):=not atom(expr) and is(op(expr)="-")$
is_const_times_sqrt(expr):=(is_product(expr) and length(args(expr)) = 2 and atom(args(expr)[1]) and is_sqrt(args(expr)[2])) or
                           (is_neg(expr) and is_const_times_sqrt(args(expr)[1])) or
                           is_sqrt(expr)$

/* sqrt(x^2)->x  */
denest_if_square(expr):=
	if is_single_sqrt(expr) and is_square(args(expr)[1])
	then
	  args(args(expr)[1])[1]
	else
	  expr$
/* expr = b*sqrt(r)->[b,r]
assumes is_const_times_sqrt(expr)*/
extract_const_sqrt(expr):=if is_sqrt(expr) then
                             [1,args(expr)[1]]
                          elseif is_neg(expr) then
			     [[-1,0],[0,1]].extract_const_sqrt(-expr)
                          else
                             [args(expr)[1],args(args(expr)[2])[1]]$

/* if args(expr)[i] is of the form b*sqrt(r) then return [expr-b*sqrt(r),b,r]
assumes expr is a sum */
denest_split_sqrt_expr(expr,i):=block([arg_i:args(expr)[i],b,r],
  if is_const_times_sqrt(arg_i) then
    block([b,r],
      [b,r]:extract_const_sqrt(arg_i),
      [expr - arg_i,b,r]))$


/* returns all possible sqrt(a+b*sqrt(r)) decompositions of expr as
   a list of [a,b,r] */
find_apbsr_decompositions(expr):=
  block([result:[]],
    if is_sqrt(expr) and is_sum(args(expr)[1]) then
      block([i,sqrt_arg:args(expr)[1]],
        for i : 1 thru length(sqrt_arg) do
           block([s:denest_split_sqrt_expr(sqrt_arg,i)],
             if not atom(s) then result:cons(s,result))),
    result)$

compute_sqrt_nesting_level(expr):=if atom(expr) then 0
                          else
                          (if is_sqrt(expr) then 1 else 0) + apply(max, map(compute_sqrt_nesting_level,args(expr)))$

position_if(predfun, list,[startpos]):=
  block([s:if is(length(startpos) = 0) then 1 else startpos[1]],
    if predfun(first(list)) then s else position_if(predfun, rest(list), 1+s))$

sets_from_lists(lists):=map(setify,lists)$
get_r_from_decomposition(decomp):=decomp[3]$
get_rs_from_decompositions(decomps):=map(get_r_from_decomposition, decomps)$
make_r_decomp_selector(r):=lambda([decomps],
  block([r_pos:find_if(lambda([decomp],is(decomp[3]=r)), decomps)],
    decomps[r]))$
select_decomps_with_r(r, decomposed_sqrt_lists):=map(make_r_decomp_selector(r), decomposed_sqrt_lists);
/* given a list of (list of apbsr decompositions), returns all possible selections with identical r for all decompositions (if any) */
find_denestable_combinations(decomposed_sqrt_lists):=block([possible_rs,possible_rs_for_components],
  possible_rs_for_components:map(get_rs_from_decompositions, decomposed_sqrt_lists),
  possible_rs:apply(intersection, sets_from_lists(possible_rs_for_components)),
  map(lambda([r],select_decomps_with_r(r, decomposed_sqrt_lists)),possible_rs))$

maybe_denestable_decompositions(exprs):=0;

/*denest(depth,nested_exprs):=block([m,n,N,d,s,DENESTED],*/
/*       m:length(nested_exprs),*/
/*       if depth = 1 then return(map(denest_if_square,nested_exprs))*/
/*       else*/
/*       block([a,b,r,denestable_decomps:maybe_denestable_decompositions(exprs)],*/
/*             if length(denestable_decomps_*/
/*             if all_list_elements_equal(r) then*/
/*                     block([],*/
/*                N:makelist(sqrt(a[i]^2-b[i]^2*r[1]),i,1,m))*/
/*             else*/
/*                DENESTED:nested_exprs*/
/*       ),*/
/*       DENESTED)$*/
